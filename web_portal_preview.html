<!DOCTYPE html>
<html>

<head>
     <title>Loadcell Datalogger Configuration</title>
     <meta name="viewport" content="width=device-width, initial-scale=1">
     <style>
          * {
               box-sizing: border-box;
          }

          body {
               font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
               margin: 0;
               padding: 20px;
               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
               min-height: 100vh;
          }

          .container {
               max-width: 1000px;
               margin: 0 auto;
               background: white;
               padding: 30px;
               border-radius: 12px;
               box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          }

          h1 {
               color: #2d3748;
               border-bottom: 3px solid #667eea;
               padding-bottom: 15px;
               margin-top: 0;
               font-size: 28px;
               display: flex;
               align-items: center;
               gap: 10px;
          }

          .section {
               margin: 25px 0;
               padding: 20px;
               background: #f7fafc;
               border-radius: 8px;
               border-left: 4px solid #667eea;
               transition: transform 0.2s, box-shadow 0.2s;
          }

          .section:hover {
               transform: translateY(-2px);
               box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          }

          .section h2 {
               margin-top: 0;
               color: #2d3748;
               font-size: 20px;
               display: flex;
               align-items: center;
               gap: 8px;
          }

          .form-group {
               margin-bottom: 20px;
          }

          label {
               display: block;
               margin: 0 0 8px 0;
               font-weight: 600;
               color: #4a5568;
               font-size: 14px;
          }

          input,
          select {
               width: 100%;
               padding: 12px;
               margin-bottom: 0;
               border: 2px solid #e2e8f0;
               border-radius: 6px;
               font-size: 14px;
               transition: border-color 0.2s, box-shadow 0.2s;
          }

          input:focus,
          select:focus {
               outline: none;
               border-color: #667eea;
               box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
          }

          button {
               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
               color: white;
               padding: 12px 24px;
               border: none;
               border-radius: 6px;
               cursor: pointer;
               font-size: 15px;
               font-weight: 600;
               margin: 5px 5px 0 0;
               transition: transform 0.2s, box-shadow 0.2s;
               box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
          }

          button:hover {
               transform: translateY(-2px);
               box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
          }

          button:active {
               transform: translateY(0);
          }

          button.secondary {
               background: #e2e8f0;
               color: #4a5568;
               box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          }

          button.secondary:hover {
               background: #cbd5e0;
               box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
          }

          .status {
               padding: 12px 16px;
               margin: 15px 0;
               border-radius: 6px;
               font-weight: 500;
               animation: slideIn 0.3s ease-out;
          }

          @keyframes slideIn {
               from {
                    opacity: 0;
                    transform: translateY(-10px);
               }

               to {
                    opacity: 1;
                    transform: translateY(0);
               }
          }

          .success {
               background: #c6f6d5;
               color: #22543d;
               border-left: 4px solid #48bb78;
          }

          .error {
               background: #fed7d7;
               color: #742a2a;
               border-left: 4px solid #f56565;
          }

          .info {
               background: #bee3f8;
               color: #2c5282;
               border-left: 4px solid #4299e1;
          }

          .status-grid {
               display: grid;
               grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
               gap: 15px;
               margin-top: 15px;
          }

          .status-card[style*="grid-column"] {
               min-width: 100%;
          }

          .status.warning {
               background: #feebc8;
               color: #7c2d12;
               border-left: 4px solid #ed8936;
          }

          .status-card {
               background: white;
               padding: 15px;
               border-radius: 8px;
               border: 2px solid #e2e8f0;
               transition: all 0.2s;
          }

          .status-card:hover {
               border-color: #667eea;
               box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          }

          .status-header {
               display: flex;
               justify-content: space-between;
               align-items: center;
               margin-bottom: 10px;
          }

          .status-label {
               font-weight: 600;
               color: #4a5568;
               font-size: 13px;
               text-transform: uppercase;
               letter-spacing: 0.5px;
          }

          .status-value {
               color: #2d3748;
               font-size: 16px;
               font-weight: 600;
          }

          .status-value.status-ok {
               color: #48bb78;
          }

          .status-value.status-warning {
               color: #ed8936;
          }

          .status-value.status-error {
               color: #f56565;
          }

          .progress-bar {
               width: 100%;
               height: 8px;
               background: #e2e8f0;
               border-radius: 4px;
               overflow: hidden;
               margin-top: 8px;
          }

          .progress-fill {
               height: 100%;
               background: linear-gradient(90deg, #48bb78, #38a169);
               border-radius: 4px;
               transition: width 0.3s ease;
          }

          .progress-fill.warning {
               background: linear-gradient(90deg, #ed8936, #dd6b20);
          }

          .progress-fill.error {
               background: linear-gradient(90deg, #f56565, #e53e3e);
          }

          .icon {
               display: inline-block;
               width: 20px;
               height: 20px;
               vertical-align: middle;
          }

          .refresh-indicator {
               display: inline-block;
               width: 16px;
               height: 16px;
               border: 2px solid #667eea;
               border-top-color: transparent;
               border-radius: 50%;
               animation: spin 1s linear infinite;
               margin-left: 8px;
          }

          @keyframes spin {
               to {
                    transform: rotate(360deg);
               }
          }

          .button-group {
               display: flex;
               flex-wrap: wrap;
               gap: 10px;
               margin-top: 15px;
          }

          @media (max-width: 768px) {
               .container {
                    padding: 20px;
               }

               .status-grid {
                    grid-template-columns: 1fr;
               }

               h1 {
                    font-size: 24px;
               }
          }

          .badge {
               display: inline-block;
               padding: 4px 8px;
               border-radius: 12px;
               font-size: 11px;
               font-weight: 600;
               text-transform: uppercase;
               letter-spacing: 0.5px;
          }

          .badge-ok {
               background: #c6f6d5;
               color: #22543d;
          }

          .badge-warning {
               background: #feebc8;
               color: #7c2d12;
          }

          .badge-error {
               background: #fed7d7;
               color: #742a2a;
          }

          small {
               color: #718096;
               font-size: 12px;
          }

          .chart-container {
               position: relative;
               height: 400px;
               margin-top: 15px;
          }

          .chart-controls {
               display: flex;
               flex-wrap: wrap;
               gap: 10px;
               margin-bottom: 15px;
               align-items: center;
          }

          .chart-controls label {
               margin: 0;
               font-weight: 500;
          }

          .chart-controls input[type="number"],
          .chart-controls select {
               width: auto;
               min-width: 100px;
               margin: 0;
          }

          .file-input-wrapper {
               position: relative;
               display: inline-block;
          }

          .file-input-wrapper input[type="file"] {
               position: absolute;
               opacity: 0;
               width: 0;
               height: 0;
          }

          .file-input-label {
               display: inline-block;
               padding: 10px 20px;
               background: #4299e1;
               color: white;
               border-radius: 6px;
               cursor: pointer;
               font-weight: 600;
               transition: background 0.2s;
          }

          .file-input-label:hover {
               background: #3182ce;
          }

          .chart-legend {
               display: flex;
               flex-wrap: wrap;
               gap: 20px;
               margin-top: 10px;
               font-size: 12px;
          }

          .legend-item {
               display: flex;
               align-items: center;
               gap: 8px;
          }

          .legend-color {
               width: 16px;
               height: 3px;
               border-radius: 2px;
          }

          /* Tab Navigation */
          .tabs {
               display: flex;
               border-bottom: 2px solid #e2e8f0;
               margin: 25px 0 0 0;
               gap: 0;
          }

          .tab {
               padding: 12px 24px;
               background: transparent;
               border: none;
               border-bottom: 3px solid transparent;
               cursor: pointer;
               font-size: 15px;
               font-weight: 600;
               color: #718096;
               transition: all 0.2s;
               position: relative;
               bottom: -2px;
          }

          .tab:hover {
               color: #4a5568;
               background: #f7fafc;
          }

          .tab.active {
               color: #667eea;
               border-bottom-color: #667eea;
               background: transparent;
          }

          .tab-content {
               display: none;
               padding: 20px 0;
          }

          .tab-content.active {
               display: block;
               animation: fadeIn 0.3s ease-in;
          }

          @keyframes fadeIn {
               from {
                    opacity: 0;
                    transform: translateY(10px);
               }

               to {
                    opacity: 1;
                    transform: translateY(0);
               }
          }
     </style>
     <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>

<body>
     <div class="container">
          <h1>
               <span>‚öôÔ∏è</span>
               Loadcell Datalogger Configuration
          </h1>

          <!-- Tab Navigation -->
          <div class="tabs">
               <button class="tab active" onclick="switchTab('status', this)">üìà Status</button>
               <button class="tab" onclick="switchTab('data', this)">üìä Data Visualization</button>
               <button class="tab" onclick="switchTab('admin', this)">‚öôÔ∏è Admin</button>
               <button class="tab" onclick="switchTab('help', this)">‚ùì Help & User Guide</button>
          </div>

          <!-- Status Tab -->
          <div id="tab-status" class="tab-content active">
               <div class="section">
                    <h2>
                         üìà System Status
                         <span id="refreshIndicator" class="refresh-indicator" style="display: none;"></span>
                    </h2>
                    <div class="status-grid" id="statusIndicators">
                         <div class="status-card">
                              <div class="status-header">
                                   <span class="status-label">üíæ SD Card</span>
                                   <span id="sdStatus" class="status-value">Checking...</span>
                              </div>
                         </div>
                         <div class="status-card" style="grid-column: span 2;">
                              <div class="status-header">
                                   <span class="status-label">üíø SD Card Storage</span>
                                   <span id="sdSpace" class="status-value">-</span>
                              </div>
                              <div style="display: flex; align-items: center; gap: 20px; margin-top: 15px;">
                                   <div style="width: 150px; height: 150px; flex-shrink: 0;">
                                        <canvas id="sdSpaceChart"></canvas>
                                   </div>
                                   <div style="flex: 1;">
                                        <div style="margin-bottom: 8px;"><strong>Total:</strong> <span
                                                  id="sdTotal">-</span></div>
                                        <div style="margin-bottom: 8px;"><strong>Free:</strong> <span
                                                  id="sdFree">-</span></div>
                                        <div style="margin-bottom: 8px;"><strong>Used:</strong> <span
                                                  id="sdUsed">-</span></div>
                                        <div id="sdSpaceStatus"
                                             style="margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 12px;">
                                        </div>
                                   </div>
                              </div>
                         </div>
                         <div class="status-card">
                              <div class="status-header">
                                   <span class="status-label">‚ö†Ô∏è Write Failures</span>
                                   <span id="writeFailures" class="status-value">-</span>
                              </div>
                         </div>
                         <div class="status-card">
                              <div class="status-header">
                                   <span class="status-label">üîå Logger State</span>
                                   <span id="loggerState" class="status-value">-</span>
                              </div>
                         </div>
                         <div class="status-card" id="batteryCard" style="display: none;">
                              <div class="status-header">
                                   <span class="status-label">üîã Battery</span>
                                   <span id="batteryStatusMain" class="status-value">-</span>
                              </div>
                              <div style="margin-top: 10px; font-size: 13px; color: #4a5568;">
                                   <div><strong>Voltage:</strong> <span id="batteryVoltage">-</span> V</div>
                                   <div><strong>Charge Rate:</strong> <span id="batteryChargeRate">-</span> %/hr</div>
                                   <div class="progress-bar" style="margin-top: 8px;">
                                        <div id="batteryProgressBar" class="progress-fill" style="width: 0%;"></div>
                                   </div>
                              </div>
                         </div>
                    </div>
               </div>
          </div>

          <!-- Admin Tab -->
          <div id="tab-admin" class="tab-content">
               <div class="section">
                    <h2>‚öôÔ∏è Admin Panel</h2>
                    <div class="warning"
                         style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 25px; color: #856404;">
                         <strong>‚ö†Ô∏è Administrator Functions</strong>
                         <p style="margin: 8px 0 0 0;">These functions are for advanced users only. Use with caution.
                         </p>
                    </div>

                    <div class="form-group" style="margin-top: 30px;">
                         <h3 style="color: #2d3748; margin-top: 0; font-size: 18px;">üì§ Firmware Upgrade</h3>
                         <p style="color: #4a5568; margin-bottom: 15px;">
                              Upload a new firmware binary file to update the device. The device will reboot after a
                              successful update.
                              <strong>Warning: Do not power off the device during the update process!</strong>
                         </p>

                         <div class="file-input-wrapper" style="margin-bottom: 15px;">
                              <input type="file" id="firmwareFile" accept=".bin"
                                   onchange="handleFirmwareFileSelect(event)">
                              <label for="firmwareFile" class="file-input-label">üìÅ Select Firmware File (.bin)</label>
                         </div>

                         <div id="firmwareFileInfo"
                              style="margin: 10px 0; padding: 10px; background: #f7fafc; border-radius: 6px; display: none;">
                              <strong>Selected file:</strong> <span id="firmwareFileName"></span><br>
                              <strong>Size:</strong> <span id="firmwareFileSize"></span>
                         </div>

                         <button type="button" class="button" id="uploadFirmwareBtn" onclick="uploadFirmware()" disabled
                              style="background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);">
                              üöÄ Upload & Update Firmware
                         </button>

                         <div id="firmwareStatus" style="margin-top: 15px;"></div>
                         <div id="firmwareProgress" style="margin-top: 10px; display: none;">
                              <div style="background: #e2e8f0; border-radius: 4px; height: 20px; overflow: hidden;">
                                   <div id="firmwareProgressBar"
                                        style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s;">
                                   </div>
                              </div>
                              <div id="firmwareProgressText" style="margin-top: 8px; font-size: 12px; color: #718096;">
                              </div>
                         </div>
                    </div>
               </div>
          </div>

          <!-- Data Visualization Tab -->
          <div id="tab-data" class="tab-content">
               <div class="section">
                    <h2 id="chartTitle">üìä Data Visualization</h2>
                    <div class="chart-controls">
                         <label>Moving Average Window:</label>
                         <select id="avgWindow" onchange="updateChart()">
                              <option value="1" selected>No Filtering</option>
                              <option value="10">10 samples</option>
                              <option value="50">50 samples</option>
                              <option value="100">100 samples</option>
                              <option value="500">500 samples</option>
                              <option value="1000">1000 samples</option>
                         </select>
                         <label>Max Points:</label>
                         <input type="number" id="maxPoints" value="5000" min="100" max="50000" step="100"
                              onchange="updateChart()">
                         <button class="secondary" onclick="reloadLatestCsv()">üîÑ Reload Latest</button>
                         <button class="secondary" onclick="showFileSelector()">üìÅ Compare Files</button>
                    </div>
                    <div id="fileComparisonPanel"
                         style="display: none; margin-top: 15px; padding: 15px; background: #f7fafc; border-radius: 8px;">
                         <h3 style="margin-top: 0; font-size: 16px;">File Comparison</h3>
                         <div id="selectedFiles" style="margin-bottom: 10px;"></div>
                         <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                              <button class="secondary" onclick="loadFileList()">üîÑ Refresh File List</button>
                              <button class="secondary" onclick="clearComparison()">üóëÔ∏è Clear All</button>
                         </div>
                         <div id="fileListContainer" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                         </div>
                    </div>
                    <div class="chart-controls"
                         style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e2e8f0;">
                         <label style="display: flex; align-items: center; gap: 10px;">
                              <input type="checkbox" id="autoRefreshToggle" onchange="toggleAutoRefresh()">
                              <span>Auto-refresh</span>
                         </label>
                         <label>Refresh Interval:</label>
                         <select id="refreshInterval" onchange="updateAutoRefresh()" disabled>
                              <option value="1000">1 second</option>
                              <option value="2000" selected>2 seconds</option>
                              <option value="5000">5 seconds</option>
                              <option value="10000">10 seconds</option>
                              <option value="30000">30 seconds</option>
                              <option value="60000">1 minute</option>
                         </select>
                         <span id="autoRefreshStatus" style="color: #718096; font-size: 12px;">Auto-refresh: OFF</span>
                    </div>
                    <div class="chart-container">
                         <canvas id="dataChart"></canvas>
                    </div>
                    <div class="chart-legend" id="chartLegend"></div>
                    <div class="chart-stats" id="chartStats"
                         style="margin-top: 15px; padding: 15px; background: #f7fafc; border-radius: 8px; font-size: 14px;">
                         <div style="margin-bottom: 15px;">
                              <strong style="display: block; margin-bottom: 8px;">Max Force (N):</strong>
                              <div id="maxForce" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                         </div>
                         <div>
                              <strong style="display: block; margin-bottom: 8px;">Max Deceleration:</strong>
                              <div id="maxDecel" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                         </div>
                    </div>
               </div>
          </div>

          <!-- Help Tab -->
          <div id="tab-help" class="tab-content">
               <div class="section">
                    <h2>‚ùì Help & User Guide</h2>
                    <div style="line-height: 1.8; color: #4a5568;">
                         <h3 style="color: #2d3748; margin-top: 0;">How to Use the Datalogger</h3>
                         <ol style="padding-left: 20px;">
                              <li><strong>Start Logging:</strong> Press the LOG_START button on the device to begin a
                                   logging
                                   session.</li>
                              <li><strong>Monitor Status:</strong> Watch the NeoPixel LED for visual feedback on system
                                   status.</li>
                              <li><strong>Stop Logging:</strong> Press the LOG_START button again to stop the session.
                              </li>
                              <li><strong>Wait for Conversion:</strong> The LED will blink orange/yellow while
                                   converting
                                   binary logs to CSV (do not remove SD card).</li>
                              <li><strong>Safe to Remove:</strong> When the LED shows a green double-blink pattern, it's
                                   safe
                                   to remove the SD card.</li>
                              <li><strong>View Data:</strong> Insert the SD card into your computer and open the CSV
                                   files in
                                   spreadsheet software.</li>
                         </ol>

                         <h3 style="color: #2d3748; margin-top: 25px;">NeoPixel LED Status Indicators</h3>
                         <p style="margin-bottom: 15px;">The NeoPixel LED provides visual feedback about the system
                              state.
                              Below are all the patterns you may see:</p>

                         <div id="neopixelPatterns" style="display: grid; gap: 15px;">
                              <!-- Patterns will be dynamically generated here -->
                         </div>
                    </div>
               </div>
          </div>

          <div id="status"></div>

     </div>

     <script>
          // Chart instance
          let dataChart = null;
          let csvData = null;
          let rawData = null;

          // Data comparison: store multiple datasets
          let comparisonData = []; // Array of {filename, data, color}
          let availableFiles = []; // List of available CSV files
          let autoRefreshInterval = null;
          let autoRefreshEnabled = false;

          // Color palette for comparison datasets
          const comparisonColors = [
               'rgb(75, 192, 192)',   // Teal
               'rgb(255, 99, 132)',   // Red
               'rgb(54, 162, 235)',   // Blue
               'rgb(255, 206, 86)',   // Yellow
               'rgb(153, 102, 255)',  // Purple
               'rgb(255, 159, 64)',   // Orange
               'rgb(201, 203, 207)', // Grey
               'rgb(255, 99, 255)'    // Magenta
          ];

          // Initialize chart
          function initChart() {
               const canvas = document.getElementById('dataChart');
               if (!canvas) {
                    console.error('Chart canvas element not found!');
                    return;
               }

               const ctx = canvas.getContext('2d');
               if (!ctx) {
                    console.error('Could not get 2D context from canvas!');
                    return;
               }

               try {
                    dataChart = new Chart(ctx, {
                         type: 'line',
                         data: {
                              labels: [],
                              datasets: [
                                   {
                                        label: 'Force (N)',
                                        data: [],
                                        borderColor: 'rgb(75, 192, 192)',
                                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                        yAxisID: 'y',
                                        borderWidth: 1.5,
                                        pointRadius: 0,
                                        tension: 0.1
                                   },
                                   {
                                        label: 'AX (g)',
                                        data: [],
                                        borderColor: 'rgb(255, 99, 132)',
                                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                        yAxisID: 'y1',
                                        borderWidth: 1.5,
                                        pointRadius: 0,
                                        tension: 0.1,
                                        hidden: false
                                   },
                                   {
                                        label: 'AY (g)',
                                        data: [],
                                        borderColor: 'rgb(54, 162, 235)',
                                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                        yAxisID: 'y1',
                                        borderWidth: 1.5,
                                        pointRadius: 0,
                                        tension: 0.1,
                                        hidden: false
                                   },
                                   {
                                        label: 'AZ (g)',
                                        data: [],
                                        borderColor: 'rgb(255, 206, 86)',
                                        backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                        yAxisID: 'y1',
                                        borderWidth: 1.5,
                                        pointRadius: 0,
                                        tension: 0.1,
                                        hidden: false
                                   },
                              ]
                         },
                         options: {
                              responsive: true,
                              maintainAspectRatio: false,
                              interaction: {
                                   mode: 'index',
                                   intersect: false,
                              },
                              plugins: {
                                   legend: {
                                        display: false
                                   },
                                   tooltip: {
                                        enabled: true,
                                        mode: 'index',
                                        intersect: false
                                   }
                              },
                              scales: {
                                   x: {
                                        title: {
                                             display: true,
                                             text: 'Time (seconds)'
                                        },
                                        grid: {
                                             color: 'rgba(0, 0, 0, 0.05)'
                                        }
                                   },
                                   y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        title: {
                                             display: true,
                                             text: 'Force (N)'
                                        },
                                        grid: {
                                             color: 'rgba(75, 192, 192, 0.1)'
                                        }
                                   },
                                   y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        title: {
                                             display: true,
                                             text: 'IMU (g / dps)'
                                        },
                                        grid: {
                                             drawOnChartArea: false
                                        }
                                   }
                              }
                         }
                    });
                    updateChartLegend();
                    console.log('Chart initialized successfully');
               } catch (error) {
                    console.error('Error initializing chart:', error);
                    showStatus('‚ùå Error initializing chart: ' + error, 'error');
               }
          }

          // Update chart legend
          function updateChartLegend() {
               const legend = document.getElementById('chartLegend');
               if (!dataChart) return;

               legend.innerHTML = '';
               dataChart.data.datasets.forEach((dataset, index) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.style.cursor = 'pointer';
                    item.onclick = () => {
                         const meta = dataChart.getDatasetMeta(index);
                         meta.hidden = !meta.hidden;
                         dataChart.update();
                         updateChartLegend();
                    };

                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = dataset.borderColor;
                    if (dataChart.getDatasetMeta(index).hidden) {
                         colorBox.style.opacity = '0.3';
                    }

                    const label = document.createElement('span');
                    label.textContent = dataset.label;
                    if (dataChart.getDatasetMeta(index).hidden) {
                         label.style.textDecoration = 'line-through';
                         label.style.opacity = '0.5';
                    }

                    item.appendChild(colorBox);
                    item.appendChild(label);
                    legend.appendChild(item);
               });
          }

          // Parse CSV data
          function parseCSV(csvText) {
               const lines = csvText.trim().split('\n');
               if (lines.length < 2) return null;

               // Skip header
               const data = [];
               for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length >= 3) {
                         data.push({
                              time: parseFloat(cols[1]),
                              adcCode: parseInt(cols[2]),
                              ax: cols.length > 4 ? parseFloat(cols[4]) : null,
                              ay: cols.length > 5 ? parseFloat(cols[5]) : null,
                              az: cols.length > 6 ? parseFloat(cols[6]) : null,
                              gx: cols.length > 7 ? parseFloat(cols[7]) : null,
                              gy: cols.length > 8 ? parseFloat(cols[8]) : null,
                              gz: cols.length > 9 ? parseFloat(cols[9]) : null
                         });
                    }
               }
               return data;
          }

          // Apply moving average filter (rolling window)
          // Parameters:
          //   - windowSize: Number of samples to average (1 = no filtering)
          //   - This uses a simple moving average (SMA) with a rolling window
          function applyMovingAverage(data, windowSize) {
               if (windowSize <= 1 || data.length === 0) return data;

               const filtered = [];
               const halfWindow = Math.floor(windowSize / 2);

               for (let i = 0; i < data.length; i++) {
                    // Calculate window bounds (centered on current point)
                    const startIdx = Math.max(0, i - halfWindow);
                    const endIdx = Math.min(data.length, i + halfWindow + 1);
                    const window = data.slice(startIdx, endIdx);

                    // Calculate moving average for this point
                    const avg = {
                         time: data[i].time,  // Keep original time
                         adcCode: window.reduce((sum, d) => sum + d.adcCode, 0) / window.length,
                         ax: data[i].ax !== null ? window.reduce((sum, d) => sum + (d.ax || 0), 0) / window.length : null,
                         ay: data[i].ay !== null ? window.reduce((sum, d) => sum + (d.ay || 0), 0) / window.length : null,
                         az: data[i].az !== null ? window.reduce((sum, d) => sum + (d.az || 0), 0) / window.length : null
                    };
                    filtered.push(avg);
               }
               return filtered;
          }

          // Update chart with data (supports comparison mode)
          function updateChart() {
               if (!dataChart) {
                    console.error('Chart not initialized!');
                    showStatus('‚ùå Chart not initialized. Please refresh the page.', 'error');
                    return;
               }

               const avgWindow = parseInt(document.getElementById('avgWindow').value);
               const maxPoints = parseInt(document.getElementById('maxPoints').value);

               // Loadcell calibration constants (hardcoded in firmware)
               const scalingFactor = 0.00667; // N per ADC count
               const adcBaseline = 8388608;    // 24-bit ADC mid-point (0N reference)

               // Convert ADC to Force (N): Force = (ADC - Baseline) * Scaling
               const convertAdcToForce = (adcCode) => {
                    return (adcCode - adcBaseline) * scalingFactor;
               };

               // Clear existing datasets (keep base structure)
               const baseDatasets = [];
               let allLabels = [];

               // Process main dataset if available
               if (rawData && rawData.length > 0) {
                    let processedData = applyMovingAverage(rawData, avgWindow);
                    if (processedData.length > maxPoints) {
                         const step = Math.ceil(processedData.length / maxPoints);
                         processedData = processedData.filter((_, i) => i % step === 0);
                    }
                    allLabels = processedData.map(d => d.time.toFixed(6));

                    // Add main dataset
                    baseDatasets.push({
                         label: 'Force (N) - Current',
                         data: processedData.map(d => ({ x: d.time, y: convertAdcToForce(d.adcCode) })),
                         borderColor: 'rgb(75, 192, 192)',
                         backgroundColor: 'rgba(75, 192, 192, 0.1)',
                         yAxisID: 'y',
                         borderWidth: 1.5,
                         pointRadius: 0,
                         tension: 0.1
                    });
                    baseDatasets.push({
                         label: 'AX (g)',
                         data: processedData.map(d => ({ x: d.time, y: d.ax !== null ? d.ax : null })),
                         borderColor: 'rgb(255, 99, 132)',
                         backgroundColor: 'rgba(255, 99, 132, 0.1)',
                         yAxisID: 'y1',
                         borderWidth: 1.5,
                         pointRadius: 0,
                         tension: 0.1,
                         hidden: false
                    });
                    baseDatasets.push({
                         label: 'AY (g)',
                         data: processedData.map(d => ({ x: d.time, y: d.ay !== null ? d.ay : null })),
                         borderColor: 'rgb(54, 162, 235)',
                         backgroundColor: 'rgba(54, 162, 235, 0.1)',
                         yAxisID: 'y1',
                         borderWidth: 1.5,
                         pointRadius: 0,
                         tension: 0.1,
                         hidden: false
                    });
                    baseDatasets.push({
                         label: 'AZ (g)',
                         data: processedData.map(d => ({ x: d.time, y: d.az !== null ? d.az : null })),
                         borderColor: 'rgb(255, 206, 86)',
                         backgroundColor: 'rgba(255, 206, 86, 0.1)',
                         yAxisID: 'y1',
                         borderWidth: 1.5,
                         pointRadius: 0,
                         tension: 0.1,
                         hidden: false
                    });

               }

               // Add comparison datasets
               const allProcessedDatasets = []; // Store processed data with labels for stats calculation
               if (rawData && rawData.length > 0) {
                    let processedData = applyMovingAverage(rawData, avgWindow);
                    if (processedData.length > maxPoints) {
                         const step = Math.ceil(processedData.length / maxPoints);
                         processedData = processedData.filter((_, i) => i % step === 0);
                    }
                    allProcessedDatasets.push({ label: 'Current', data: processedData });
               }

               comparisonData.forEach((comp, idx) => {
                    if (comp.data && comp.data.length > 0) {
                         let processedComp = applyMovingAverage(comp.data, avgWindow);
                         if (processedComp.length > maxPoints) {
                              const step = Math.ceil(processedComp.length / maxPoints);
                              processedComp = processedComp.filter((_, i) => i % step === 0);
                         }

                         // Store for stats calculation
                         allProcessedDatasets.push({ label: comp.filename, data: processedComp });

                         // Use comparison color
                         const color = comp.color || comparisonColors[idx % comparisonColors.length];

                         baseDatasets.push({
                              label: `Force (N) - ${comp.filename}`,
                              data: processedComp.map(d => ({ x: d.time, y: convertAdcToForce(d.adcCode) })),
                              borderColor: color,
                              backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                              yAxisID: 'y',
                              borderWidth: 1.5,
                              pointRadius: 0,
                              tension: 0.1,
                              borderDash: [5, 5] // Dashed line for comparison
                         });
                    }
               });

               // Update chart
               dataChart.data.labels = allLabels;
               dataChart.data.datasets = baseDatasets;
               dataChart.update('none');
               updateChartLegend();

               // Calculate and display max values for all datasets (main + comparison)
               // Map dataset labels to their colors
               const datasetColors = {};
               baseDatasets.forEach((ds, idx) => {
                    // Only track Force datasets (yAxisID === 'y')
                    if (ds.yAxisID === 'y') {
                         let label = ds.label.replace('Force (N) - ', '');
                         // Map "Current" to match the dataset label
                         if (label === 'Current') {
                              label = 'Current';
                         }
                         datasetColors[label] = ds.borderColor;
                    }
               });
               updateChartStats(allProcessedDatasets, datasetColors);

               const totalPoints = (rawData ? rawData.length : 0) + comparisonData.reduce((sum, comp) => sum + (comp.data ? comp.data.length : 0), 0);
               showStatus(`‚úÖ Chart updated: ${baseDatasets.length} datasets, ${totalPoints} total points`, 'success');
          }

          // Update chart statistics (max force and max deceleration) for all datasets
          function updateChartStats(datasets, datasetColors = {}) {
               const maxForceEl = document.getElementById('maxForce');
               const maxDecelEl = document.getElementById('maxDecel');

               if (!datasets || datasets.length === 0) {
                    if (maxForceEl) maxForceEl.innerHTML = '<span style="color: #718096;">-</span>';
                    if (maxDecelEl) maxDecelEl.innerHTML = '<span style="color: #718096;">-</span>';
                    return;
               }

               // Loadcell calibration constants (hardcoded in firmware)
               const scalingFactor = 0.00667; // N per ADC count
               const adcBaseline = 8388608;    // 24-bit ADC mid-point (0N reference)

               // Calculate stats for each dataset
               const stats = [];
               datasets.forEach(dataset => {
                    if (!dataset.data || dataset.data.length === 0) return;

                    // Find max ADC and convert to Force (N)
                    let maxAdc = dataset.data[0].adcCode;
                    let maxAdcTime = dataset.data[0].time;
                    for (let i = 1; i < dataset.data.length; i++) {
                         if (dataset.data[i].adcCode > maxAdc) {
                              maxAdc = dataset.data[i].adcCode;
                              maxAdcTime = dataset.data[i].time;
                         }
                    }
                    const maxForceN = (maxAdc - adcBaseline) * scalingFactor;

                    // Find max deceleration (max AZ value)
                    let maxDecel = null;
                    let maxDecelTime = null;
                    for (let i = 0; i < dataset.data.length; i++) {
                         if (dataset.data[i].az !== null && (maxDecel === null || dataset.data[i].az > maxDecel)) {
                              maxDecel = dataset.data[i].az;
                              maxDecelTime = dataset.data[i].time;
                         }
                    }

                    // Get color for this dataset
                    const color = datasetColors[dataset.label] || 'rgb(75, 192, 192)';

                    stats.push({
                         label: dataset.label,
                         maxForce: maxForceN,
                         maxForceTime: maxAdcTime,
                         maxDecel: maxDecel,
                         maxDecelTime: maxDecelTime,
                         color: color
                    });
               });

               // Update display - show stats in color-coded containers
               if (maxForceEl) {
                    maxForceEl.innerHTML = '';
                    if (stats.length === 0) {
                         maxForceEl.innerHTML = '<span style="color: #718096;">-</span>';
                    } else {
                         stats.forEach(stat => {
                              const badge = document.createElement('div');
                              badge.style.cssText = `display: inline-block; padding: 6px 12px; margin: 4px 0; background: ${stat.color.replace('rgb', 'rgba').replace(')', ', 0.15)')}; border-left: 4px solid ${stat.color}; border-radius: 4px; font-size: 13px; color: #2d3748;`;
                              badge.innerHTML = `<strong style="color: ${stat.color};">${stat.label}:</strong> ${stat.maxForce.toFixed(2)} N at ${stat.maxForceTime.toFixed(6)}s`;
                              maxForceEl.appendChild(badge);
                         });
                    }
               }

               if (maxDecelEl) {
                    maxDecelEl.innerHTML = '';
                    if (stats.length === 0) {
                         maxDecelEl.innerHTML = '<span style="color: #718096;">-</span>';
                    } else {
                         stats.forEach(stat => {
                              const badge = document.createElement('div');
                              badge.style.cssText = `display: inline-block; padding: 6px 12px; margin: 4px 0; background: ${stat.color.replace('rgb', 'rgba').replace(')', ', 0.15)')}; border-left: 4px solid ${stat.color}; border-radius: 4px; font-size: 13px; color: #2d3748;`;
                              if (stat.maxDecel !== null) {
                                   badge.innerHTML = `<strong style="color: ${stat.color};">${stat.label}:</strong> ${stat.maxDecel.toFixed(3)}g at ${stat.maxDecelTime.toFixed(6)}s`;
                              } else {
                                   badge.innerHTML = `<strong style="color: ${stat.color};">${stat.label}:</strong> N/A`;
                              }
                              maxDecelEl.appendChild(badge);
                         });
                    }
               }
          }

          // Parse filename to extract date/time for chart title
          // Format: YYYYMMDD_HHMMSS.csv (e.g., "20251204_153012.csv")
          function parseFilenameForTitle(filename) {
               if (!filename) return 'Data Visualization';

               // Remove path and extension
               const basename = filename.replace(/^.*\//, '').replace(/\.csv$/, '');

               // Parse YYYYMMDD_HHMMSS format
               const match = basename.match(/^(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})$/);
               if (match) {
                    const [, year, month, day, hour, minute, second] = match;
                    const dateStr = `${year}-${month}-${day}`;
                    const timeStr = `${hour}:${minute}:${second}`;
                    return `üìä ${dateStr} ${timeStr}`;
               }

               // Fallback: use filename as-is
               return `üìä ${basename}`;
          }

          // Load latest CSV from ESP32 (or use mock data for preview)
          async function loadLatestCsv() {
               // Check if we're in preview mode (file:// protocol)
               if (window.location.protocol === 'file:') {
                    // Use mock data for preview
                    await loadMockData();
                    return;
               }

               try {
                    showStatus('Loading CSV file list...', 'info');
                    const listResponse = await fetch('/csv/list');
                    const fileList = await listResponse.json();

                    if (!fileList || fileList.length === 0) {
                         showStatus('‚ùå No CSV files found on SD card', 'error');
                         return;
                    }

                    // Get the most recent file (assuming files are named with timestamp)
                    const latestFile = fileList[fileList.length - 1];

                    showStatus('Loading CSV file: ' + latestFile.filename + '...', 'info');
                    const fileResponse = await fetch('/csv/file?file=' + encodeURIComponent(latestFile.filename));

                    if (!fileResponse.ok) {
                         showStatus('‚ùå Error loading CSV file: ' + fileResponse.statusText, 'error');
                         return;
                    }

                    const csvText = await fileResponse.text();
                    rawData = parseCSV(csvText);

                    if (!rawData || rawData.length === 0) {
                         showStatus('‚ùå Error: Invalid CSV file or no data found', 'error');
                         return;
                    }

                    // Update chart title with filename
                    const title = parseFilenameForTitle(latestFile.filename);
                    document.getElementById('chartTitle').textContent = title;

                    showStatus('‚úÖ Loaded ' + rawData.length + ' data points from ' + latestFile.filename, 'success');
                    updateChart();
               } catch (error) {
                    showStatus('‚ùå Error loading CSV: ' + error + ' (Using mock data for preview)', 'error');
                    // Fallback to mock data if fetch fails
                    await loadMockData();
               }
          }

          // Reload latest CSV (for manual refresh)
          async function reloadLatestCsv() {
               showStatus('Reloading latest CSV...', 'info');
               await loadLatestCsv();
          }

          // Mock function for preview (simulates ESP32 CSV list/file endpoints)
          // Generates realistic 10-minute logging session with force profile:
          // - 0G freefall initially
          // - Random 3G spike (~20kN) for 10ms
          // - ~1G deceleration for rest of session
          async function loadMockData() {
               // Generate mock CSV data with realistic filename format
               const now = new Date();
               const year = now.getFullYear();
               const month = String(now.getMonth() + 1).padStart(2, '0');
               const day = String(now.getDate()).padStart(2, '0');
               const hour = String(now.getHours()).padStart(2, '0');
               const minute = String(now.getMinutes()).padStart(2, '0');
               const second = String(now.getSeconds()).padStart(2, '0');
               const mockFilename = `${year}${month}${day}_${hour}${minute}${second}.csv`;

               let csvText = 'ADC_Index,Time_Seconds,ADC_Code,IMU_Index,AX,AY,AZ,GX,GY,GZ\n';

               // Session parameters
               const sessionDurationSeconds = 600; // 10 minutes
               const adcSampleRate = 64000; // 64 ksps
               const imuSampleRate = 960; // 960 Hz
               const totalAdcSamples = sessionDurationSeconds * adcSampleRate;

               // For preview, we'll downsample to keep file size reasonable
               // Generate every Nth sample to get ~100k points for smooth visualization
               const downsampleFactor = Math.max(1, Math.floor(totalAdcSamples / 100000));
               const previewSamples = Math.floor(totalAdcSamples / downsampleFactor);

               // Force profile parameters
               // ADC baseline (0G freefall) - assume mid-scale for 24-bit ADC
               const adcBaseline = 8388608; // 2^23 (mid-point of 24-bit signed)
               const adcNoiseLevel = 1000; // Small noise in freefall

               // 3G spike corresponds to ~20kN on loadcell
               // Assuming linear relationship: 1G = ~6.67kN, so 3G = 20kN
               // ADC sensitivity: need to calculate based on loadcell calibration
               // For simulation: assume 3G spike = +3,000,000 ADC counts from baseline
               const adcSpikeAmplitude = 3000000; // 3G spike magnitude
               const spikeDurationSeconds = 0.01; // 10ms
               const spikeDurationSamples = Math.ceil(spikeDurationSeconds * adcSampleRate); // ~640 samples

               // Random spike timing: occurs between 0.1s and 2.0s after start
               const spikeStartMin = 0.1;
               const spikeStartMax = 2.0;
               const spikeStartTime = spikeStartMin + Math.random() * (spikeStartMax - spikeStartMin);
               const spikeStartSample = Math.floor(spikeStartTime * adcSampleRate);
               const spikeEndSample = spikeStartSample + spikeDurationSamples;

               // Post-spike deceleration: ~1G
               const postSpikeG = 1.0; // 1G deceleration
               const adcPostSpikeOffset = adcSpikeAmplitude / 3; // Proportional to 1G

               // IMU parameters
               let imuSampleCounter = 0;
               const imuSamplesPerAdc = adcSampleRate / imuSampleRate; // ~66.67

               // Generate data
               for (let previewIdx = 0; previewIdx < previewSamples; previewIdx++) {
                    const adcIndex = previewIdx * downsampleFactor;
                    const time = adcIndex / adcSampleRate;

                    // Calculate ADC code based on force profile
                    let adcCode;
                    if (time < spikeStartTime) {
                         // Phase 1: 0G freefall (before spike)
                         adcCode = adcBaseline + (Math.random() - 0.5) * adcNoiseLevel;
                    } else if (time >= spikeStartTime && time < (spikeStartTime + spikeDurationSeconds)) {
                         // Phase 2: 3G spike (10ms duration)
                         const spikeProgress = (time - spikeStartTime) / spikeDurationSeconds;
                         // Smooth spike: rapid rise, then fall
                         const spikeShape = Math.sin(spikeProgress * Math.PI); // Bell curve shape
                         adcCode = adcBaseline + adcSpikeAmplitude * spikeShape;
                         // Add some noise
                         adcCode += (Math.random() - 0.5) * adcNoiseLevel * 2;
                    } else {
                         // Phase 3: ~1G deceleration (after spike)
                         // Gradual decay from spike to steady 1G
                         const timeAfterSpike = time - (spikeStartTime + spikeDurationSeconds);
                         const decayTime = 0.5; // 500ms decay time
                         const decayFactor = Math.exp(-timeAfterSpike / decayTime);
                         const steadyState = adcPostSpikeOffset;
                         adcCode = adcBaseline + steadyState + (adcSpikeAmplitude - steadyState) * decayFactor;
                         // Add noise
                         adcCode += (Math.random() - 0.5) * adcNoiseLevel;
                    }

                    // Round to integer
                    adcCode = Math.round(adcCode);

                    // Generate IMU data (accelerometer aligned with force profile)
                    let ax, ay, az;
                    if (time < spikeStartTime) {
                         // 0G freefall
                         ax = (Math.random() - 0.5) * 0.05;
                         ay = (Math.random() - 0.5) * 0.05;
                         az = (Math.random() - 0.5) * 0.05;
                    } else if (time >= spikeStartTime && time < (spikeStartTime + spikeDurationSeconds)) {
                         // 3G spike (assuming spike is in Z direction)
                         const spikeProgress = (time - spikeStartTime) / spikeDurationSeconds;
                         const spikeShape = Math.sin(spikeProgress * Math.PI);
                         ax = (Math.random() - 0.5) * 0.1;
                         ay = (Math.random() - 0.5) * 0.1;
                         az = 3.0 * spikeShape + (Math.random() - 0.5) * 0.2;
                    } else {
                         // ~1G deceleration
                         const timeAfterSpike = time - (spikeStartTime + spikeDurationSeconds);
                         const decayTime = 0.5;
                         const decayFactor = Math.exp(-timeAfterSpike / decayTime);
                         ax = (Math.random() - 0.5) * 0.1;
                         ay = (Math.random() - 0.5) * 0.1;
                         az = 1.0 + (2.0 * decayFactor) + (Math.random() - 0.5) * 0.1;
                    }

                    // IMU sample index (only increment when we cross IMU sample boundary)
                    const imuIndex = Math.floor(adcIndex / imuSamplesPerAdc);

                    csvText += `${adcIndex},${time.toFixed(6)},${adcCode},${imuIndex},${ax.toFixed(6)},${ay.toFixed(6)},${az.toFixed(6)},0.0,0.0,0.0\n`;
               }

               rawData = parseCSV(csvText);

               // Update chart title
               const title = parseFilenameForTitle(mockFilename);
               document.getElementById('chartTitle').textContent = title;

               showStatus(`‚úÖ Loaded mock data: ${rawData.length} points (${sessionDurationSeconds}s session, spike at ${spikeStartTime.toFixed(3)}s)`, 'success');
               updateChart();
          }


          // Mock data for preview (simulates ESP32 responses)
          const mockConfig = {
               adcSampleRate: 64000,
               adcPgaGain: 2,
               imuOdr: 960,
               imuAccelRange: 16,
               imuGyroRange: 2000
          };

          // Simulate different status scenarios
          let statusScenario = 0;
          const mockStatusScenarios = [
               // Scenario 0: Normal operation
               {
                    adc: { buffered: 512, overflow: 0, counter: 123456 },
                    imu: { buffered: 256, overflow: 0 },
                    logger: { state: 0, sessionOpen: false },
                    sd: { mounted: true, present: true, freeSpace: 1024 * 1024 * 1024, totalSpace: 8 * 1024 * 1024 * 1024, freePercent: 87.5 },
                    writes: { adcFailures: 0, imuFailures: 0, adcConsecutiveFailures: 0, imuConsecutiveFailures: 0 },
                    memory: { freeHeap: 200000, totalHeap: 500000, freePercent: 40.0 }
               },
               // Scenario 1: High buffer usage
               {
                    adc: { buffered: 1900, overflow: 0, counter: 456789 },
                    imu: { buffered: 900, overflow: 0 },
                    logger: { state: 1, sessionOpen: true },
                    sd: { mounted: true, present: true, freeSpace: 512 * 1024 * 1024, totalSpace: 8 * 1024 * 1024 * 1024, freePercent: 93.75 },
                    writes: { adcFailures: 2, imuFailures: 1, adcConsecutiveFailures: 0, imuConsecutiveFailures: 0 },
                    memory: { freeHeap: 150000, totalHeap: 500000, freePercent: 30.0 }
               },
               // Scenario 2: Warning conditions
               {
                    adc: { buffered: 1600, overflow: 0, counter: 789012 },
                    imu: { buffered: 800, overflow: 0 },
                    logger: { state: 2, sessionOpen: false },
                    sd: { mounted: true, present: true, freeSpace: 200 * 1024 * 1024, totalSpace: 8 * 1024 * 1024 * 1024, freePercent: 97.5 },
                    writes: { adcFailures: 5, imuFailures: 3, adcConsecutiveFailures: 2, imuConsecutiveFailures: 1 },
                    memory: { freeHeap: 100000, totalHeap: 500000, freePercent: 20.0 }
               },
               // Scenario 3: Error conditions
               {
                    adc: { buffered: 2000, overflow: 5, counter: 999999 },
                    imu: { buffered: 1000, overflow: 2 },
                    logger: { state: 0, sessionOpen: false },
                    sd: { mounted: false, present: false, freeSpace: 0, totalSpace: 0, freePercent: 0 },
                    writes: { adcFailures: 20, imuFailures: 15, adcConsecutiveFailures: 8, imuConsecutiveFailures: 6 },
                    memory: { freeHeap: 50000, totalHeap: 500000, freePercent: 10.0 },
                    battery: { present: true, voltage: 3.7, soc: 15.0, chargeRate: -2.5, alert: true }
               }
          ];

          // Add battery data to other scenarios
          mockStatusScenarios[0].battery = { present: true, voltage: 4.2, soc: 85.0, chargeRate: 0.5, alert: false };
          mockStatusScenarios[1].battery = { present: true, voltage: 3.9, soc: 65.0, chargeRate: -1.2, alert: false };
          mockStatusScenarios[2].battery = { present: true, voltage: 3.6, soc: 35.0, chargeRate: -2.0, alert: false };

          function showStatus(message, type) {
               const statusDiv = document.getElementById('status');
               statusDiv.className = 'status ' + type;
               statusDiv.textContent = message;
               setTimeout(() => statusDiv.textContent = '', 4000);
          }

          // Note: ADC/IMU configuration has been moved to the calibration portal (/cal)

          // Update system status indicators
          async function updateStatusIndicators() {
               const refreshIndicator = document.getElementById('refreshIndicator');
               refreshIndicator.style.display = 'inline-block';

               try {
                    // Simulate network delay
                    await new Promise(resolve => setTimeout(resolve, 200));

                    // Get mock data (cycle through scenarios for demo)
                    const data = mockStatusScenarios[statusScenario];

                    // SD Card status
                    const sdStatusEl = document.getElementById('sdStatus');
                    if (data.sd && data.sd.mounted && data.sd.present) {
                         sdStatusEl.textContent = '‚úì OK';
                         sdStatusEl.className = 'status-value status-ok';
                    } else {
                         sdStatusEl.textContent = '‚úó ERROR';
                         sdStatusEl.className = 'status-value status-error';
                    }

                    // SD Card free space (pie chart)
                    const sdSpaceEl = document.getElementById('sdSpace');
                    const sdTotalEl = document.getElementById('sdTotal');
                    const sdFreeEl = document.getElementById('sdFree');
                    const sdUsedEl = document.getElementById('sdUsed');
                    const sdSpaceStatusEl = document.getElementById('sdSpaceStatus');

                    if (data.sd && data.sd.totalSpace > 0) {
                         const freeMB = (data.sd.freeSpace / (1024 * 1024)).toFixed(1);
                         const totalMB = (data.sd.totalSpace / (1024 * 1024)).toFixed(1);
                         const usedMB = ((data.sd.totalSpace - data.sd.freeSpace) / (1024 * 1024)).toFixed(1);
                         const percent = data.sd.freePercent;

                         sdSpaceEl.textContent = percent.toFixed(1) + '% Free';
                         sdTotalEl.textContent = totalMB + ' MB';
                         sdFreeEl.textContent = freeMB + ' MB';
                         sdUsedEl.textContent = usedMB + ' MB';

                         // Update progress bar
                         const sdSpaceBar = document.getElementById('sdSpaceBar');
                         if (sdSpaceBar) {
                              sdSpaceBar.style.width = percent + '%';
                              if (percent < 10) {
                                   sdSpaceBar.className = 'progress-fill error';
                              } else if (percent < 25) {
                                   sdSpaceBar.className = 'progress-fill warning';
                              } else {
                                   sdSpaceBar.className = 'progress-fill';
                              }
                         }

                         // Status message
                         if (percent < 10) {
                              sdSpaceEl.className = 'status-value status-error';
                              sdSpaceStatusEl.className = 'status error';
                              sdSpaceStatusEl.textContent = '‚ö†Ô∏è Critical: Less than 10% free space remaining!';
                         } else if (percent < 25) {
                              sdSpaceEl.className = 'status-value status-warning';
                              sdSpaceStatusEl.className = 'status warning';
                              sdSpaceStatusEl.textContent = '‚ö†Ô∏è Warning: Less than 25% free space remaining.';
                         } else {
                              sdSpaceEl.className = 'status-value status-ok';
                              sdSpaceStatusEl.className = 'status success';
                              sdSpaceStatusEl.textContent = '‚úì Storage space is healthy.';
                         }
                    } else {
                         sdSpaceEl.textContent = 'N/A';
                         sdSpaceEl.className = 'status-value';
                         sdTotalEl.textContent = '-';
                         sdFreeEl.textContent = '-';
                         sdUsedEl.textContent = '-';

                         // Reset progress bar
                         const sdSpaceBar = document.getElementById('sdSpaceBar');
                         if (sdSpaceBar) {
                              sdSpaceBar.style.width = '0%';
                              sdSpaceBar.className = 'progress-fill';
                         }

                         if (sdSpaceStatusEl) {
                              sdSpaceStatusEl.textContent = '';
                              sdSpaceStatusEl.className = '';
                         }
                    }

                    // Write Failures
                    const writeFailuresEl = document.getElementById('writeFailures');
                    if (data.writes) {
                         const totalFailures = data.writes.adcFailures + data.writes.imuFailures;
                         const consecutive = Math.max(data.writes.adcConsecutiveFailures, data.writes.imuConsecutiveFailures);
                         if (totalFailures === 0 && consecutive === 0) {
                              writeFailuresEl.textContent = '‚úì None';
                              writeFailuresEl.className = 'status-value status-ok';
                         } else {
                              writeFailuresEl.textContent = 'Total: ' + totalFailures + ' | Consecutive: ' + consecutive;
                              if (consecutive >= 5) {
                                   writeFailuresEl.className = 'status-value status-error';
                              } else if (consecutive > 0) {
                                   writeFailuresEl.className = 'status-value status-warning';
                              } else {
                                   writeFailuresEl.className = 'status-value status-ok';
                              }
                         }
                    } else {
                         writeFailuresEl.textContent = '-';
                         writeFailuresEl.className = 'status-value';
                    }

                    // Logger State
                    const loggerStateEl = document.getElementById('loggerState');
                    const states = ['IDLE', 'SESSION_OPEN', 'CONVERTING'];
                    const stateText = states[data.logger.state] || 'UNKNOWN';
                    loggerStateEl.textContent = stateText;
                    if (data.logger.state === 1) { // SESSION_OPEN
                         loggerStateEl.className = 'status-value status-ok';
                    } else if (data.logger.state === 2) { // CONVERTING
                         loggerStateEl.className = 'status-value status-warning';
                    } else {
                         loggerStateEl.className = 'status-value';
                    }

                    // Battery Status
                    const batteryCard = document.getElementById('batteryCard');
                    const batteryStatusEl = document.getElementById('batteryStatusMain');
                    const batteryVoltageEl = document.getElementById('batteryVoltage');
                    const batteryChargeRateEl = document.getElementById('batteryChargeRate');
                    const batteryProgressBar = document.getElementById('batteryProgressBar');

                    if (data.battery && data.battery.present) {
                         batteryCard.style.display = 'block';

                         if (data.battery.error) {
                              batteryStatusEl.textContent = 'Error';
                              batteryStatusEl.className = 'status-value status-error';
                              batteryVoltageEl.textContent = '-';
                              batteryChargeRateEl.textContent = '-';
                              batteryProgressBar.style.width = '0%';
                         } else {
                              const soc = data.battery.soc || 0;
                              const voltage = data.battery.voltage || 0;
                              const chargeRate = data.battery.chargeRate || 0;

                              batteryStatusEl.textContent = soc.toFixed(1) + '%';
                              batteryVoltageEl.textContent = voltage.toFixed(2);
                              batteryChargeRateEl.textContent = chargeRate >= 0 ?
                                   '+' + chargeRate.toFixed(2) : chargeRate.toFixed(2);

                              // Update progress bar
                              batteryProgressBar.style.width = soc + '%';

                              // Color coding
                              if (soc < 20) {
                                   batteryStatusEl.className = 'status-value status-error';
                                   batteryProgressBar.className = 'progress-fill error';
                              } else if (soc < 50) {
                                   batteryStatusEl.className = 'status-value status-warning';
                                   batteryProgressBar.className = 'progress-fill warning';
                              } else {
                                   batteryStatusEl.className = 'status-value status-ok';
                                   batteryProgressBar.className = 'progress-fill';
                              }
                         }
                    } else {
                         batteryCard.style.display = 'none';
                    }
               } catch (error) {
                    console.error('Error updating status indicators:', error);
               } finally {
                    refreshIndicator.style.display = 'none';
               }
          }

          // Cycle through scenarios for demo (every 5 seconds)
          setInterval(() => {
               statusScenario = (statusScenario + 1) % mockStatusScenarios.length;
          }, 5000);

          // Update status indicators every 2 seconds
          setInterval(updateStatusIndicators, 2000);

          // NeoPixel pattern definitions (matching neopixel.cpp)
          const neopixelPatterns = [
               {
                    name: 'OFF',
                    description: 'LED is off',
                    color: '#000000',
                    pattern: 'solid',
                    timing: null
               },
               {
                    name: 'INIT',
                    description: 'System initializing / peripherals starting up',
                    color: '#FF5000', // RGB(255, 80, 0) - amber
                    pattern: 'solid',
                    timing: null
               },
               {
                    name: 'READY',
                    description: 'System ready to start logging (breathing green pattern)',
                    color: '#00FF00', // RGB(0, 255, 0) - green
                    pattern: 'breathing',
                    timing: { period: 2000, minBrightness: 30, maxBrightness: 255 }
               },
               {
                    name: 'LOGGING',
                    description: 'Actively logging data to SD card',
                    color: '#00FF00', // RGB(0, 255, 0) - green
                    pattern: 'solid',
                    timing: null
               },
               {
                    name: 'CONVERTING',
                    description: 'Converting binary logs to CSV (DO NOT remove SD card)',
                    color: '#FF6400', // RGB(255, 100, 0) - orange/yellow
                    pattern: 'blink',
                    timing: { on: 150, off: 150, pulses: 1, gap: 0 }
               },
               {
                    name: 'SAFE TO REMOVE',
                    description: 'CSV conversion complete (safe to remove SD card)',
                    color: '#00FF00', // RGB(0, 255, 0) - green
                    pattern: 'double-blink',
                    timing: { on: 100, off: 100, pulses: 2, gap: 800 }
               },
               {
                    name: 'ERROR: SD Card',
                    description: 'SD card initialization or access error',
                    color: '#FF0000', // RGB(255, 0, 0) - red
                    pattern: 'double-blink',
                    timing: { on: 100, off: 100, pulses: 2, gap: 600 }
               },
               {
                    name: 'ERROR: RTC',
                    description: 'Real-time clock initialization error',
                    color: '#FFFF00', // RGB(255, 255, 0) - yellow
                    pattern: 'blink',
                    timing: { on: 200, off: 800, pulses: 1, gap: 0 }
               },
               {
                    name: 'ERROR: IMU',
                    description: 'IMU (accelerometer/gyroscope) initialization error',
                    color: '#FF00FF', // RGB(255, 0, 255) - magenta
                    pattern: 'triple-blink',
                    timing: { on: 80, off: 80, pulses: 3, gap: 600 }
               },
               {
                    name: 'ERROR: ADC',
                    description: 'ADC (loadcell) initialization error',
                    color: '#00FFFF', // RGB(0, 255, 255) - cyan
                    pattern: 'blink',
                    timing: { on: 500, off: 500, pulses: 1, gap: 0 }
               },
               {
                    name: 'ERROR: Write Failure',
                    description: 'Persistent SD card write failures (critical)',
                    color: '#FF0000', // RGB(255, 0, 0) - red
                    pattern: 'fast-blink',
                    timing: { on: 50, off: 50, pulses: 1, gap: 0 }
               },
               {
                    name: 'ERROR: Low Space',
                    description: 'SD card running low on free space',
                    color: '#FFA500', // RGB(255, 165, 0) - orange
                    pattern: 'double-blink',
                    timing: { on: 200, off: 200, pulses: 2, gap: 400 }
               },
               {
                    name: 'ERROR: Buffer Full',
                    description: 'ADC or IMU ring buffer overflow',
                    color: '#FF0080', // RGB(255, 0, 128) - purple/magenta
                    pattern: 'triple-blink',
                    timing: { on: 60, off: 60, pulses: 3, gap: 500 }
               },
               {
                    name: 'LOW BATTERY',
                    description: 'Battery state of charge below 20% (orange solid glow)',
                    color: '#FFA500', // RGB(255, 165, 0) - orange
                    pattern: 'solid',
                    timing: null
               }
          ];

          // Generate NeoPixel pattern display with animations
          function generateNeopixelPatterns() {
               const container = document.getElementById('neopixelPatterns');
               if (!container) return;

               container.innerHTML = '';

               neopixelPatterns.forEach(pattern => {
                    const patternDiv = document.createElement('div');
                    patternDiv.style.cssText = 'background: white; padding: 15px; border-radius: 8px; border: 2px solid #e2e8f0; display: flex; align-items: center; gap: 15px;';

                    // LED indicator
                    const ledDiv = document.createElement('div');
                    ledDiv.style.cssText = 'width: 40px; height: 40px; border-radius: 50%; background: ' + pattern.color + '; box-shadow: 0 0 10px ' + pattern.color + '; position: relative; flex-shrink: 0;';

                    // Add animation based on pattern type
                    if (pattern.pattern === 'breathing' && pattern.timing) {
                         const period = pattern.timing.period / 1000; // Convert ms to seconds
                         ledDiv.style.animation = `breathing ${period}s ease-in-out infinite`;
                    } else if (pattern.pattern === 'blink' && pattern.timing) {
                         const duration = (pattern.timing.on + pattern.timing.off) / 1000;
                         ledDiv.style.animation = `blink ${duration}s infinite`;
                    } else if (pattern.pattern === 'double-blink' && pattern.timing) {
                         const cycleTime = (pattern.timing.on + pattern.timing.off) * pattern.timing.pulses + pattern.timing.gap;
                         ledDiv.style.animation = `doubleBlink ${cycleTime / 1000}s infinite`;
                    } else if (pattern.pattern === 'triple-blink' && pattern.timing) {
                         const cycleTime = (pattern.timing.on + pattern.timing.off) * pattern.timing.pulses + pattern.timing.gap;
                         ledDiv.style.animation = `tripleBlink ${cycleTime / 1000}s infinite`;
                    } else if (pattern.pattern === 'fast-blink' && pattern.timing) {
                         const duration = (pattern.timing.on + pattern.timing.off) / 1000;
                         ledDiv.style.animation = `blink ${duration}s infinite`;
                    }

                    // Text info
                    const textDiv = document.createElement('div');
                    textDiv.style.cssText = 'flex: 1;';
                    textDiv.innerHTML = `
                    <div style="font-weight: 600; color: #2d3748; margin-bottom: 4px;">${pattern.name}</div>
                    <div style="font-size: 13px; color: #718096;">${pattern.description}</div>
                `;

                    patternDiv.appendChild(ledDiv);
                    patternDiv.appendChild(textDiv);
                    container.appendChild(patternDiv);
               });
          }

          // Tab switching function
          function switchTab(tabName, element) {
               // Hide all tabs
               document.querySelectorAll('.tab-content').forEach(tab => {
                    tab.classList.remove('active');
               });
               document.querySelectorAll('.tab').forEach(btn => {
                    btn.classList.remove('active');
               });

               // Show selected tab
               document.getElementById('tab-' + tabName).classList.add('active');
               if (element) {
                    element.classList.add('active');
               } else {
                    // Fallback: find the button by text content
                    document.querySelectorAll('.tab').forEach(btn => {
                         if (btn.textContent.includes(tabName === 'status' ? 'Status' : tabName === 'data' ? 'Data Visualization' : 'Help')) {
                              btn.classList.add('active');
                         }
                    });
               }

               // Initialize tab content if needed
               if (tabName === 'data' && !dataChart) {
                    initChart();
                    setTimeout(loadLatestCsv, 100);
               } else if (tabName === 'help' && document.getElementById('neopixelPatterns').children.length === 0) {
                    generateNeopixelPatterns();
               }
          }

          // ========================================================================
          // Firmware Upload Functions
          // ========================================================================
          function handleFirmwareFileSelect(event) {
               const file = event.target.files[0];
               const fileInfo = document.getElementById('firmwareFileInfo');
               const fileName = document.getElementById('firmwareFileName');
               const fileSize = document.getElementById('firmwareFileSize');
               const uploadBtn = document.getElementById('uploadFirmwareBtn');

               if (file) {
                    if (!file.name.endsWith('.bin')) {
                         alert('Error: Please select a .bin firmware file');
                         event.target.value = '';
                         return;
                    }

                    fileName.textContent = file.name;
                    fileSize.textContent = (file.size / 1024).toFixed(1) + ' KB';
                    fileInfo.style.display = 'block';
                    uploadBtn.disabled = false;
               } else {
                    fileInfo.style.display = 'none';
                    uploadBtn.disabled = true;
               }
          }

          async function uploadFirmware() {
               const fileInput = document.getElementById('firmwareFile');
               const file = fileInput.files[0];
               const statusDiv = document.getElementById('firmwareStatus');
               const progressDiv = document.getElementById('firmwareProgress');
               const progressBar = document.getElementById('firmwareProgressBar');
               const progressText = document.getElementById('firmwareProgressText');
               const uploadBtn = document.getElementById('uploadFirmwareBtn');

               if (!file) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = '‚ùå Please select a firmware file first';
                    return;
               }

               // Confirm action
               if (!confirm('‚ö†Ô∏è WARNING: This will update the device firmware and reboot it.\n\nDo not power off the device during the update!\n\nContinue?')) {
                    return;
               }

               uploadBtn.disabled = true;
               uploadBtn.textContent = '‚è≥ Uploading...';
               progressDiv.style.display = 'block';
               progressBar.style.width = '0%';
               progressText.textContent = 'Starting upload...';

               statusDiv.className = 'status info';
               statusDiv.textContent = 'üì§ Uploading firmware... Please wait. Do not close this page!';

               try {
                    const formData = new FormData();
                    formData.append('firmware', file);

                    const xhr = new XMLHttpRequest();

                    // Track upload progress
                    xhr.upload.addEventListener('progress', (e) => {
                         if (e.lengthComputable) {
                              const percent = Math.round((e.loaded / e.total) * 100);
                              progressBar.style.width = percent + '%';
                              progressText.textContent = `Uploading: ${percent}% (${(e.loaded / 1024).toFixed(1)} KB / ${(e.total / 1024).toFixed(1)} KB)`;
                         }
                    });

                    xhr.addEventListener('load', () => {
                         if (xhr.status === 200) {
                              progressBar.style.width = '100%';
                              progressText.textContent = 'Upload complete!';
                              statusDiv.className = 'status success';
                              statusDiv.textContent = '‚úÖ Firmware uploaded successfully! Device is rebooting...';
                              uploadBtn.textContent = '‚úÖ Update Complete';

                              // Wait a bit then show message
                              setTimeout(() => {
                                   statusDiv.innerHTML = '‚úÖ Firmware update complete!<br>The device is rebooting. You can close this page.<br>It may take 30-60 seconds for the device to come back online.';
                              }, 2000);
                         } else {
                              throw new Error('Upload failed: ' + xhr.statusText);
                         }
                    });

                    xhr.addEventListener('error', () => {
                         throw new Error('Upload failed: Network error');
                    });

                    xhr.open('POST', '/admin/firmware/upload');
                    xhr.send(formData);

               } catch (error) {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = '‚ùå Error: ' + error.message;
                    progressBar.style.width = '0%';
                    progressText.textContent = 'Failed';
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'üöÄ Upload & Update Firmware';
               }
          }

          // Add CSS animations for blink patterns and breathing
          const style = document.createElement('style');
          style.textContent = `
            @keyframes breathing {
                0%, 100% { 
                    opacity: 0.12; /* ~30/255 brightness */
                    transform: scale(0.95);
                }
                50% { 
                    opacity: 1; /* 255/255 brightness */
                    transform: scale(1);
                }
            }
            @keyframes blink {
                0%, 50% { opacity: 1; }
                50.01%, 100% { opacity: 0.1; }
            }
            @keyframes doubleBlink {
                0%, 4.5% { opacity: 1; }
                4.51%, 9% { opacity: 0.1; }
                9.01%, 13.5% { opacity: 1; }
                13.51%, 18% { opacity: 0.1; }
                18.01%, 100% { opacity: 0.1; }
            }
            @keyframes tripleBlink {
                0%, 2.5% { opacity: 1; }
                2.51%, 5% { opacity: 0.1; }
                5.01%, 7.5% { opacity: 1; }
                7.51%, 10% { opacity: 0.1; }
                10.01%, 12.5% { opacity: 1; }
                12.51%, 100% { opacity: 0.1; }
            }
        `;
          document.head.appendChild(style);

          // Note: ADC/IMU configuration has been moved to the calibration portal (/cal)

          // File comparison functions
          async function showFileSelector() {
               const panel = document.getElementById('fileComparisonPanel');
               panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
               if (panel.style.display === 'block') {
                    await loadFileList();
               }
          }

          async function loadFileList() {
               const container = document.getElementById('fileListContainer');
               container.innerHTML = '<p>Loading file list...</p>';

               try {
                    if (window.location.protocol === 'file:') {
                         // Mock file list for preview
                         availableFiles = [
                              { filename: '20241204_120000.csv', size: 1024000 },
                              { filename: '20241204_130000.csv', size: 1024000 },
                              { filename: '20241204_140000.csv', size: 1024000 }
                         ];
                    } else {
                         const response = await fetch('/csv/list');
                         availableFiles = await response.json();
                    }

                    container.innerHTML = '';
                    if (availableFiles.length === 0) {
                         container.innerHTML = '<p style="color: #718096;">No CSV files found.</p>';
                         return;
                    }

                    availableFiles.forEach((file, idx) => {
                         const fileDiv = document.createElement('div');
                         fileDiv.style.cssText = 'padding: 10px; margin: 5px 0; background: white; border-radius: 6px; border: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;';

                         const fileInfo = document.createElement('span');
                         fileInfo.textContent = file.filename + ' (' + (file.size / 1024).toFixed(1) + ' KB)';

                         const addBtn = document.createElement('button');
                         addBtn.textContent = '‚ûï Add';
                         addBtn.className = 'secondary';
                         addBtn.style.cssText = 'padding: 6px 12px; font-size: 12px;';
                         addBtn.onclick = () => addFileToComparison(file.filename);

                         // Check if already added
                         if (comparisonData.find(c => c.filename === file.filename)) {
                              addBtn.textContent = '‚úì Added';
                              addBtn.disabled = true;
                              addBtn.style.opacity = '0.5';
                         }

                         fileDiv.appendChild(fileInfo);
                         fileDiv.appendChild(addBtn);
                         container.appendChild(fileDiv);
                    });
               } catch (error) {
                    container.innerHTML = '<p style="color: #f56565;">Error loading file list: ' + error + '</p>';
               }
          }

          async function addFileToComparison(filename) {
               // Check if already added
               if (comparisonData.find(c => c.filename === filename)) {
                    showStatus('File already added to comparison', 'info');
                    return;
               }

               try {
                    showStatus('Loading ' + filename + '...', 'info');
                    let csvText;

                    if (window.location.protocol === 'file:') {
                         // Generate mock data for preview
                         csvText = await generateMockCsvForFile(filename);
                    } else {
                         const response = await fetch('/csv/file?file=' + encodeURIComponent(filename));
                         if (!response.ok) throw new Error('Failed to load file');
                         csvText = await response.text();
                    }

                    const parsedData = parseCSV(csvText);
                    if (!parsedData || parsedData.length === 0) {
                         showStatus('Error: Invalid CSV file', 'error');
                         return;
                    }

                    const color = comparisonColors[comparisonData.length % comparisonColors.length];
                    comparisonData.push({ filename, data: parsedData, color });

                    updateComparisonDisplay();
                    updateChart();
                    showStatus('‚úÖ Added ' + filename + ' to comparison', 'success');
               } catch (error) {
                    showStatus('‚ùå Error loading file: ' + error, 'error');
               }
          }

          function updateComparisonDisplay() {
               const container = document.getElementById('selectedFiles');
               if (comparisonData.length === 0) {
                    container.innerHTML = '<p style="color: #718096; font-size: 12px;">No files selected for comparison.</p>';
                    return;
               }

               container.innerHTML = '<strong style="font-size: 12px; margin-bottom: 8px; display: block;">Selected Files (' + comparisonData.length + '):</strong>';
               comparisonData.forEach((comp, idx) => {
                    const fileTag = document.createElement('div');
                    fileTag.style.cssText = 'display: inline-block; padding: 6px 12px; margin: 4px; background: white; border-radius: 6px; border: 2px solid ' + comp.color + '; font-size: 12px;';
                    fileTag.innerHTML = '<span style="display: inline-block; width: 12px; height: 12px; background: ' + comp.color + '; border-radius: 50%; margin-right: 6px;"></span>' + comp.filename + ' <button onclick="removeFromComparison(\'' + comp.filename + '\')" style="margin-left: 8px; background: #f56565; color: white; border: none; border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 10px;">‚úï</button>';
                    container.appendChild(fileTag);
               });
          }

          function removeFromComparison(filename) {
               comparisonData = comparisonData.filter(c => c.filename !== filename);
               updateComparisonDisplay();
               updateChart();
               loadFileList(); // Refresh to re-enable add button
          }

          function clearComparison() {
               comparisonData = [];
               updateComparisonDisplay();
               updateChart();
               loadFileList();
          }

          // Auto-refresh functions
          function toggleAutoRefresh() {
               const toggle = document.getElementById('autoRefreshToggle');
               const intervalSelect = document.getElementById('refreshInterval');
               autoRefreshEnabled = toggle.checked;

               intervalSelect.disabled = !autoRefreshEnabled;

               if (autoRefreshEnabled) {
                    startAutoRefresh();
               } else {
                    stopAutoRefresh();
               }
          }

          function updateAutoRefresh() {
               if (autoRefreshEnabled) {
                    stopAutoRefresh();
                    startAutoRefresh();
               }
          }

          function startAutoRefresh() {
               stopAutoRefresh(); // Clear any existing interval

               const interval = parseInt(document.getElementById('refreshInterval').value);
               const statusEl = document.getElementById('autoRefreshStatus');

               statusEl.textContent = 'Auto-refresh: ON (' + (interval / 1000) + 's)';
               statusEl.style.color = '#48bb78';

               autoRefreshInterval = setInterval(() => {
                    updateStatusIndicators();
                    if (rawData) {
                         reloadLatestCsv();
                    }
               }, interval);
          }

          function stopAutoRefresh() {
               if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
               }
               const statusEl = document.getElementById('autoRefreshStatus');
               statusEl.textContent = 'Auto-refresh: OFF';
               statusEl.style.color = '#718096';
          }

          // Generate mock CSV for file comparison (for preview mode)
          async function generateMockCsvForFile(filename) {
               // Similar to loadMockData but with slight variations for comparison
               let csvText = 'ADC_Index,Time_Seconds,ADC_Code,IMU_Index,AX,AY,AZ,GX,GY,GZ\n';

               const sessionDurationSeconds = 600;
               const adcSampleRate = 64000;
               const downsampleFactor = Math.max(1, Math.floor(sessionDurationSeconds * adcSampleRate / 100000));
               const previewSamples = Math.floor(sessionDurationSeconds * adcSampleRate / downsampleFactor);

               const adcBaseline = 8388608;
               const adcNoiseLevel = 1000;
               const spikeAmplitude = 3000000 + (Math.random() - 0.5) * 500000; // Slight variation
               const spikeStartTime = 0.1 + Math.random() * 1.9;

               for (let i = 0; i < previewSamples; i++) {
                    const adcIndex = i * downsampleFactor;
                    const time = adcIndex / adcSampleRate;

                    let adcCode;
                    if (time < spikeStartTime) {
                         adcCode = adcBaseline + (Math.random() - 0.5) * adcNoiseLevel;
                    } else if (time < spikeStartTime + 0.01) {
                         const spikeProgress = (time - spikeStartTime) / 0.01;
                         adcCode = adcBaseline + spikeAmplitude * Math.sin(spikeProgress * Math.PI);
                    } else {
                         const timeAfterSpike = time - (spikeStartTime + 0.01);
                         const decayFactor = Math.exp(-timeAfterSpike / 0.5);
                         adcCode = adcBaseline + (spikeAmplitude / 3) + (spikeAmplitude * 2 / 3) * decayFactor;
                    }

                    const ax = (Math.random() - 0.5) * 0.1;
                    const ay = (Math.random() - 0.5) * 0.1;
                    const az = time < spikeStartTime ? (Math.random() - 0.5) * 0.05 : 1.0 + (Math.random() - 0.5) * 0.1;

                    csvText += `${adcIndex},${time.toFixed(6)},${Math.round(adcCode)},${Math.floor(adcIndex / (adcSampleRate / 960))},${ax.toFixed(6)},${ay.toFixed(6)},${az.toFixed(6)},0.0,0.0,0.0\n`;
               }

               return csvText;
          }

          // Ensure Chart.js is loaded before initializing charts
          function waitForChartJS(callback) {
               if (typeof Chart !== 'undefined') {
                    callback();
               } else {
                    setTimeout(() => waitForChartJS(callback), 100);
               }
          }

          // Load config on page load
          window.onload = function () {
               waitForChartJS(() => {
                    // Initialize chart first
                    initChart();
                    // Then update status indicators (which includes pie chart)
                    updateStatusIndicators();
                    generateNeopixelPatterns();  // Generate help section
                    updateComparisonDisplay();  // Initialize comparison display
                    // Auto-load latest CSV on page load
                    setTimeout(loadLatestCsv, 500);
               });
          };
     </script>
</body>

</html>